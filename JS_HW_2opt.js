// 1. Написать скриптик, который сосчитает и выведет результат от возведения 2 в степень 10, начиная со степени 1
// 1 вариант
for (let i = 1; i <= 10; i++) {
  let number = 2
  console.log(number ** i)
}

// 2 вариант
for(let i = 1; i < 11; i++) {
  console.log(2 ** i)
}

// 3 вариант
for(let i = 1; i < 11; i++) {
  console.log(Math.pow(2, i))   // Math.pow(base, exponent) - метод, возвращает основание, возведенное в степень показатель, то есть, значение выражения основание\показатель. base - основание степени, exponent - показатель степени, в которую возводится основание base.
}

// 1*. Преобразовать 1 задачу в функцию, принимающую на вход степень, в которую будет возводиться число 2
//  1 вариант
function power(b) {
  for (i = 1; i <= b; i++) {
    let a = 2  
    console.log(a ** i)
  }
}
power(10)

// 2 вариант
const pow = function(counter) {
  for(let i = 1; i <= counter; i++) {
    console.log(2 ** i)
  }
}
pow(10)

// 2. Написать скрипт, который выведет 5 строк в консоль таким образом, чтобы в первой строчке выводилось :), во второй :):) и так далее. Пример в консоли :), :):), :):):), :):):):), :):):):):)
// 1 вариант
for(i = 1; i <= 5; i++) {
  console.log(':)'.repeat(i))   // str.repeat(count) - метод, конструирующий и возвращающий новую строку, содержащую указанное количество соединенных вместе копий строки, на которой он был вызван
}

// 2 вариант
let result = ''
let smile = ':)'

for(let i = 1; i < 6; i++) {
  console.log(result += smile)   // (+=) сложение с присваиванием, добавляет значение правого операнда к переменной и присваивает переменной результат
}

for(let i = 1; i < 6; i++) {
  console.log(smile.repeat(i))
}

// 2*. Преобразовать 2 задачу в функцию, принимающую на вход строку, которая и будет выводится в консоль (как в условии смайлик), а также количество строк для вывода e.g. function printSmile(stroka, numberOfRows)
// 1 вариант
function printSmile(stroka, numberOfRows) {
  for(let i = 1; i <= numberOfRows; i++) {
    console.log(stroka.repeat(i))
  }
}
printSmile(':)', 5)

// 2 вариант
function smilik(str, numberOfRows) {
  let result = ''
  for(let i = 1; i <= numberOfRows; i++) {
    console.log(result += str)
  }
}
smilik(':)', 5)

// 3 вариант
function smilik(str, numberOfRows) {
  let result = ''
  for(let i = 1; i <= numberOfRows; i++) {
    result = result + str
    console.log(result)
  }
}
smilik(':)', 5)

// 3**. Написать функцию, которая принимает на вход слово. Задача функции посчитать и вывести в консоль, сколько в слове гласных, и сколько согласных букв. e.g. function getWordStructure(word). В консоли: Слово (word) состоит из (число) гласных и (число) согласных букв. Проверки: 'case', 'Case', 'Check-list'
// 1 вариант
function getWordStructure2(word) {
  const vowels = 'aeiou'.split('')   // str.split( [separator[, limit]]) - разбивает объект String на массив строк путем разделения строки указанной подстрокой. separator -необязательный параметр, указывает символы используемые в качестве разделителя внутри строки, может быть как строкой, так и регулярным выражением. Если параметр опущен, возвращенный массив будет содержать один элемент со всей строкой. Если параметр равен пустой строке(''), строка str будет преобразована в массив символов. limit - необязательный параметр, целое число, определяющее ограничение на количество найденных подстрок. Метод split() все равно разделяет строку на каждом сопоставлении с разделителем separator, но обрезает возвращаемый массив так, чтобы он содержал не более limit элементов. Метод split() возвращает новый массив.
  const consonants = 'bcdfghjklmnpqrstyvwxz'.split('')

  let vowelsCount = 0
  let consonantsCount = 0

  for(const char of word.toLowerCase()) {   // str.toLowerCase() - метод, возвращает значение строки, на которой он был вызван, преобразованное в нижний регистр
    if(vowels.includes(char)) vowelsCount++   // str.includes(searchString[, position]) - метод проверяет, содержит ли строка заданную подстроку, и возвращает, соответственно true или false. searchString - строка для поиска в данной строке. position - позиция в строке, с которой начинать поиск строки searchString, по умолчанию 0. true, если искомая строка была найдена в данной строке; иначе false. Этот метод позволяет определять, содержит ли строка другую строку, является регистрозависимым.
    else if(consonants.indexOf(char) !== -1) consonantsCount++   // str.indexOf(searchValue, [fromIndex]) - метод, возвращает индекс первого вхождения указанного значения в строковый объект String, на котором он был вызван, начиная с индекса fromIndex. Возвращает -1, если значение не найдено.searchValue - строка, представляющая искомое значение. fromIndex - необязательный параметр, местоположение внутри строки, откуда начинать поиск. Может быть любым целым числом. Значение по умолчанию установлено в 0. Является регистрозависимым. Проверка на вхождение. Значение 0 не вычисляется в true, а значение -1 не вычисляется в false. Поэтому для проверки того, что конкретная строка содержится в другой строке, правильно делать так: 'Синий кит'.indexOf('Синий') !== -1 // true
  }
  console.log(`Слово ${word} состоит из ${vowelsCount} гласных и ${consonantsCount} согласных букв`)   // обратные кавычки `` (буква ё) позволяют не только создать строку, но и вставлять произвольные выражения, обернув их в ${...}, могут занимать более одной строки, также позволяют задавать шаблонную функцию перед обратной кавычкой
}
getWordStructure2('Check-list')

// 2 вариант
function getWordStructure3(word) {
  console.log(`Слово ${word} состоит из ${(word.match(/[aeiou]/gi)) ? (word.match(/[aeiou]/gi)).length : 0} гласных и ${(word.match(/[bcdfghjklmnpqrstyvwxz]/gi)) ? (word.match(/[bcdfghjklmnpqrstyvwxz]/gi)).length : 0} согласных букв`)   // str.length - свойство, содержит длину строки. Так как это числовое свойство, а не функция, добавлять скобки не нужно. str.match(regexp) - метод, возвращает получившиеся совпадения при сопоставлении строки с регулярным выражением. regexp - объект регулярного выражения. Если будет передан объект obj, не являющийся регулярным выражением, он будет неявно преобразован  в объект RegExp через вызов конструктора new RegExp(obj). Если регулярное выражение содержит флаг g, метод вернет массив, содержащий все сопоставления. Регулярное выражение состоит из шаблона и необязательных флагов. В коротком синтаксисе используются слэши /.../ - говорят о том, что это регулярное выражение. Флаг i - поиск не зависит от регистра, флаг g - ищет все совпадения, без него - только первое. Использование регулярных выражений интегрировано в методы строк. Метод str.match(regexp) для строки str возвращает совпадения с регулярным выражением regexp. ? - условный (тернарный) оператор, определяет переменную в зависимости от условия. Сначала вычисляется условие : если оно истинно, тогда возвращается значение1, в противном случае - значение2: let result = условие ? значение1 : значение2. Иногда оператор ? используется в качестве замены if. В зависимости от условия будет выполнена либо первая, либо вторая часть после ?. Здесь не присваивается результат перменной. Вместо этого выполняется различный код в зависимости от условия.
}
getWordStructure3('Check-list')

// 4**. Написать функцию, которая проверяет, является ли слово палиндромом e.g. function isPalindrom(word). Проверки: 'abba', 'Abba'
// 1 вариант
function isPalindrom(word) {
  word = word.toLowerCase()
  for(let i = 0, j = word.length-1; i < word.length, j >= 0; i++, j--) {   // str.length возвращает размер массива, нумеруя элементы с единицы, а сам массив нумерует с нуля, поэтому результат этой функции будет, фактически, на 1 больше реального размера. Если не вычесть единицу (str.length-1), то на последней итерации выйдем за пределы массива. Еще раз массивы в JS индексируются с нуля: первый элемент массива имеет индекс, равный 0, а индекс последнего элемента равен значению массива length минус 1.
    if(word[i] !== word[j]) {   // сравниваются в каждой итерации элементы слова по 1 с начала и конца и если не равны то false
      return false
    }
  }
  return true
}
console.log(isPalindrom('abba'))

// 2 вариант
function isPalindrom2(word) {
  return word.toLowerCase() === word.toLowerCase().split('').reverse().join('')   // .reverse() - на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний - первым (перевернутый массив) .join() - преобразует все элементы массива в строки и объединяет их в одну большую строку с использованием пустой строки (получается строка - слово наоборот). Слово и слово наоборот строго сравниваются
}
console.log(isPalindrom2('Abba'))

// 3 вариант
function isPalindrom3(word) {
  word = word.toLowerCase()
  for(let i = 0; i <= word.length/2; i++) {
    if(word[i] !== word[word.length-1-i])
      return false
  }
  return true
}
console.log(isPalindrom3('saha'))